
### 1.概述：
```
我的总结：
    c和c++拥有高的内存管理，可以对内存进行操作，Java语言的内存管理交由java虚拟机在管理，这样在创建对象的时候，最后不需要自己delete这个空间，但是如果处理内存溢出和内存泄露，这个时候就必须了解虚拟机才可以。

```
### 2.运行时数据区域
```
我的总结：
    在java程序运行的过程中，会将内存划分为若干个不同的区域，不同的区域完成不同的功能，它的主要分为
    程序计数器、方法区、虚拟机栈、本地方法栈、堆

```
## 2.1.程序计数器
```

我的总结：
    首先它是指示当前字节码文件执行到的行号，在执行java方法，指示的是java字节码的行号，如果执行的是本地方法，那么就是null，他也是唯一一个没有内存溢出错误的区域。
    他通过指针的指示完成程序代码的执行，分支、循环、递归、异常处理、线程恢复等操作。

    java虚拟机是多线程执行的，所以他通过轮流的方式来执行，由于某一个时刻去执行另一个任务，这个任务可能未执行结束，为了可以接着执行，所以需要记住这个标记，所以他是私有的，各个程序计数器是互不影响的。

```
## 2.2.java虚拟机栈
```

我的总结：
    java虚拟机栈是一个私有空间，他存储的是栈帧，它的声明周期同线程，每个方法的执行，都会创建一个栈帧
    栈帧存储的是局部变量表、操作数栈，动态链，方法出口，方法的执行，就是入栈和出栈的过程。

    这个区域会有两种溢出异常：
        栈溢出：如果深度超过了最大深度就会出现栈溢出
        内存溢出：如果创建栈的时候，无法申请到足够的内部，就会出现内存溢出。
补充：
    局部变量表：存储的是各种基本数据类型和对象引用。

```
##2.3本地方法栈
```

    同于java虚拟机栈，他只是执行的是本地方法
```
##java堆
```
   
    java堆是内存占用最大的一块，他也是垃圾主要回收的位置，他在虚拟机启动的时候创建，它的所有线程共享的区域，她存储的主要是数组和对象。【主要是因为栈上也可以存储，逃逸技术】

    现在的垃圾回收主要是分代垃圾回收，所有为了方便垃圾回收，他会将堆分为年轻带和老年代，在细分eden、Survivor【From survior /to survior】

    java虚拟机可以是不连续的单元，只有逻辑上连续就可以了。

    对于大小可以进行设置，如果堆上的内存无法扩展，那么就会发生内存溢出溢出

补充：
    内存溢出和内存泄露
    内存泄露是即用不了，也回收不了
    内存溢出是超出了内存的范围，超出了最大值

```
## 方法区
```   
   
    方法区他是共享的，它主要存储的是类信息，编译后的字节码文件，静态变量，常量。
    有时候也会将方法区称为是一个永久代
    1.7的时候将常量池溢出

    java虚拟机对于方法区的大小是可以选择固定或者向外扩展的，但是并不要求，必须有垃圾回收，它的垃圾回收量是比较少的

    对象卸载也会发生在这个区域中，当分配内存无法达到需求的时候，也会发生内存溢出的

```
## 运行时常量池
```

    他是方法区的一部分，class文件除了有类的版本、字段、方法、接口等信息，还有常量信息，用于存放编译时期各种字面量和符号引用。

    无论那一部分的内容都必须有一定的规范，这样才会被加载和执行，

    这一部分的数据，不一定要在编译时期产生，在运行的是也是可以产生的 。比如String的intern

```
## 直接内存
```

```
## Hotspot
```

```
##它是如何创建对象的
```
    平时创建对象可以通过克隆和new，序列化，反射
    （1）虚拟机做了什么？
        遇到new关键字
        ·会去检查这个指令的参数是否可以在常量池中定位一个类放入符号引用，并且检查是否已经被加载、解析、初始化。
          未已经初始化，那就先执行类的加载，解析初始化【说点别的：我面试的时候，说在方法区查找，这个并没哟错，常量池本身就在方法区中】
        ·检查过后，开始分配空间，也就是在堆中划分一块内存
        指针碰撞:
            假设内存是规整的，所有的用过的数据内存都放在一边,内存指示的位置，有一个内存

























    