
### 1.概述：
```
我的总结：
    c和c++拥有高的内存管理，可以对内存进行操作，Java语言的内存管理交由java虚拟机在管理，这样在创建对象的时候，最后不需要自己delete这个空间，但是如果处理内存溢出和内存泄露，这个时候就必须了解虚拟机才可以。

```
### 2.运行时数据区域
```
我的总结：
    在java程序运行的过程中，会将内存划分为若干个不同的区域，不同的区域完成不同的功能，它的主要分为
    程序计数器、方法区、虚拟机栈、本地方法栈、堆

```
## 2.1.程序计数器
```

我的总结：
    首先它是指示当前字节码文件执行到的行号，在执行java方法，指示的是java字节码的行号，如果执行的是本地方法，那么就是null，他也是唯一一个没有内存溢出错误的区域。
    他通过指针的指示完成程序代码的执行，分支、循环、递归、异常处理、线程恢复等操作。

    java虚拟机是多线程执行的，所以他通过轮流的方式来执行，由于某一个时刻去执行另一个任务，这个任务可能未执行结束，为了可以接着执行，所以需要记住这个标记，所以他是私有的，各个程序计数器是互不影响的。

```
## 2.2.java虚拟机栈
```

我的总结：
    java虚拟机栈是一个私有空间，他存储的是栈帧，它的声明周期同线程，每个方法的执行，都会创建一个栈帧
    栈帧存储的是局部变量表、操作数栈，动态链，方法出口，方法的执行，就是入栈和出栈的过程。

    这个区域会有两种溢出异常：
        栈溢出：如果深度超过了最大深度就会出现栈溢出
        内存溢出：如果创建栈的时候，无法申请到足够的内部，就会出现内存溢出。
补充：
    局部变量表：存储的是各种基本数据类型和对象引用。

```
##2.3本地方法栈
```

    同于java虚拟机栈，他只是执行的是本地方法
```
##java堆
```
   
    java堆是内存占用最大的一块，他也是垃圾主要回收的位置，他在虚拟机启动的时候创建，它的所有线程共享的区域，她存储的主要是数组和对象。【主要是因为栈上也可以存储，逃逸技术】

    现在的垃圾回收主要是分代垃圾回收，所有为了方便垃圾回收，他会将堆分为年轻带和老年代，在细分eden、Survivor【From survior /to survior】

    java虚拟机可以是不连续的单元，只有逻辑上连续就可以了。

    对于大小可以进行设置，如果堆上的内存无法扩展，那么就会发生内存溢出溢出

补充：
    内存溢出和内存泄露
    内存泄露是即用不了，也回收不了
    内存溢出是超出了内存的范围，超出了最大值

```
## 方法区
```   
   
    方法区他是共享的，它主要存储的是类信息，编译后的字节码文件，静态变量，常量。
    有时候也会将方法区称为是一个永久代
    1.7的时候将常量池溢出

    java虚拟机对于方法区的大小是可以选择固定或者向外扩展的，但是并不要求，必须有垃圾回收，它的垃圾回收量是比较少的

    对象卸载也会发生在这个区域中，当分配内存无法达到需求的时候，也会发生内存溢出的

```
## 运行时常量池
```

    他是方法区的一部分，class文件除了有类的版本、字段、方法、接口等信息，还有常量信息，用于存放编译时期各种字面量和符号引用。

    无论那一部分的内容都必须有一定的规范，这样才会被加载和执行，

    这一部分的数据，不一定要在编译时期产生，在运行的是也是可以产生的 。比如String的intern

```
## 直接内存
```

```
### Hotspot
```

```
## 它是如何创建对象的
```
    平时创建对象可以通过克隆和new，序列化，反射
    （1）虚拟机做了什么？
        遇到new关键字
        ·会去检查这个指令的参数是否可以在常量池中定位一个类放入符号引用，并且检查是否已经被加载、解析、初始化。
          未已经初始化，那就先执行类的加载，解析初始化【说点别的：我面试的时候，说在方法区查找，这个并没哟错，常量池本身就在方法区中】
        ·检查过后，开始分配空间，也就是在堆中划分一块内存
        指针碰撞:
            （1）概念：假设内存是规整的，所有的用过的数据内存都放在一边,内存指示的位置，分配的时候将指示器向后移动分配内存大小个距离
            （2）条件：内存必须规整
        空闲列表：
            （1）概念：内存是不规整的，交互交错的，这个时候就必须有一张表记录，那一块的内存是可以使用的，在分配的时候，找出一段可以使用的分配给实例，并更新表

```
# 面试
```
    
        对象创建时非常频繁的，假如一个对象创建的时候，在A分配空间，但是指针还没有来得及更改，同时B又同时使用原来指针分配的空间？？？
        （1）一种就是在分配的时候进行同步处理，采用虚拟机提供的CAS配上失败重试的方式保证更新操作的原子性
        （2）在内存分配的动作按照线程划分在不同的空间之中进行，即就是每一个线程在java堆中预先分配一个小的内存
            那个线程要分配空间，那个线程的缓冲区上分配

    （2）分配完成之后，就会将其初始化为0值，如果是同缓冲区，那么就是在分配缓冲区的时候执行这一操作。
         它可以保证在程序未在构造函数中赋初值就可以使用，可以访问到这些0值
    
        内存分配了   0值也赋予了  下来应该是他属于谁了

    （3）将属于哪一个实例。如何找到元数据信息。对象的哈希码、对象的GC分代年龄都放在对象头中

    （4）因为默认都是0值，这个时候按照程序员的意愿来进行初始化。

```
## 对象的内布局
```

    对象的内存布局分为：对象头、实例数据、对齐填充
    （1）对象头
        对象头包括两部分：
        存储对象自身的运行时数据：
            如哈希码、gc分代年龄、锁状态、线程持有的锁、时间戳，它的长度和系统的位数有关
            那么多数据，他有不是数据，那么就采取一些措施将其变的更加的小。
        类型指针：
            对象指向它的类元数据的指针，通过它来确定这个对象是哪一个类的实体
















    